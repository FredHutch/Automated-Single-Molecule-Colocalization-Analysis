function [data, SK, ISOR, StatsPix, survData] = asmca(registeredfile,frameRate, varargin)

% asmca function measures colocalization events between DNA fragments and 2
% other fluorescently labelled molecules from timeseries data generated by
% TIRF microscopy as described in Popchock et al.
%
% Input:    -registeredfile: Registered image dataset with 3 channels
% (channel#1 is DNA). Usually an *.ome.tiff file coming from TIRFRegister()
%           -frameRate: frame rate in seconds per frame -varargin:
%           thresholds for converting channel#2 (varargin{1}) and channel#3
%           (varagin{2}) traces  to ON/OFF states, based on z-normalized
%           intensities.
%
% Output:   -data: structure array containing traces of each channel after
%                  signal processing (numframes-by-numspots)
%                   SDC: structure containing raw and lowpass DNA traces
%                   SRC: structure containing raw, lowpass, pulsed
%                   (quantum) and binary (ON/OFF) channel1 traces SGC: same
%                   as SRC for channel#2 censorR and censorG: cell array (1
%                   cell per traces) containing vector of censored pulses
%                   (1) or not (0) for channel#2 and #3, respectively.
%                   Empty vectors reflect the absence of pulses WR and WG:
%                   duration of pulses in sec for channel#2 and #3,
%                   respectively. IR and IG: initiation time of first pulse
%                   for channel#2 and #3, respectively. dutyR and dutyG:
%                   fraction of time on ON state for channel#2 and #3,
%                   respectively. TC1 and TC2: threshold value for
%                   channel#1 and #2
%
%           -SK:vector of indices of traces with pulses in both
%           (SRC(:,SK(i)) and  SGC(:,SK(i)) show when protein ch#1 and
%           protein ch#2 bind  to the SK(i)th DNA  molecule  on the slide.
%           channels
%
%           -ISOR: x-by-y-by-numChannels-by-1-by-numframes matrix
%           containing the registered channel stacks
%
%           -StatsPix: Structure containing centroids and surrounding
%           background pixels (Pixbkg) indices of each DNA spot -survData:
%           1-by-2 cell array (one per interrogated channel), each
%           containing a m-by-2 matrix, first column being duration of
%           pulse, second column being censorship. Input for survivor
%           function
%
% ASMCA also outputs 3 figures: figure 1 shows DNA spots with intensity
% corresponding to time persistency, with red circles highlighting analyzed
% spots
%figure 2 shows a random trace from channel1 figure 3 shows the survivor
%function for channel 1 and 2
%
% Examples:
%
% Analyze 'DemoImage.ome.tiff' dataset:5 seconds per frame, default
% thresholds:
%
% [data,SK, ISOR, StatsPix, survData] = ASMCA('DemoImage.ome.tiff',5);
%
% Analyze 'DemoImage.ome.tiff' dataset:15 sec per frame, custom thresholds
% (0.47 for channel1 and 0.33 for channel2)
%
% [data,SK, ISOR, StatsPix, survData] = ASMCA('DemoImage.ome.tiff',15,
% 0.47,0.33);
%
% Created by Julien Dubrulle, 2020

close all
warning off


%% Casually checking input arguments
if ~ismember(nargin,[2 4])
    disp('Wrong number of arguments!')
    return
end

%% Import and organize imaging data

IS = bfopen(registeredfile);
nim = size(IS{1,1},1); % number of tatal images in tiff file


if contains(registeredfile,'ome') % registered stack from TIRFRegister() saved in ome.tiff format
    B = cat(3,IS{1,1}{1 : nim / 3,1});
    R = cat(3,IS{1,1}{nim / 3 + 1 : 2 * nim / 3,1});
    G = cat(3,IS{1,1}{2 * nim / 3 + 1 :end,1});
else                              % regular .tif file
    B = cat(3,IS{1,1}{1:3:end,1});
    R = cat(3,IS{1,1}{2:3:end,1});
    G = cat(3,IS{1,1}{3:3:end,1});
end
[sx, sy, st] = size(B);




ISOR = zeros(sx, sy, st, 1, 3,'like',B);
ISOR(:,:,:,1,1) = B;
ISOR(:,:,:,1,2) = R;
ISOR(:,:,:,1,3) = G;


BW = false(size(B));


%% Process DNA channel

progressText(0,'DNA spots detection');
for i = 1:st
    I = B(:,:,i);
    Ia = imadjust(I);
    T = minminT(Ia); % background value detection
    IW = bwareaopen(Ia > T, 5); % Binarization and size filtration
    if i == 1
        SIW = bwmorph(~IW,'skel',Inf); % SIW will be used to find local background pixels

    end


    BW(:,:,i) = IW;
    B(:,:,i) = Ia;
    progressText(i/st);
end

Breg = double(B);
Rreg = double(R);
Greg = double(G);

% define DNA pixel persistency
BWa = sum(BW,3);
BWan = BWa / st;

[~,PW] = FastPeakFind(BWa); % find summit of DNA intensity peaks (most likely centers of  DNA spots)


PW(BWan < 0.8) = 0;         % discard DNA pixels that persist less than 80% of the time

PWd = bwmorph(logical(PW),'thicken',2); % create  artifical spot of  radius 2 pixels
PWda = bwareafilt(PWd,[32 37]);         % select size to fit spots of size of single DNA molecule

BB = bwboundaries(PWda);
CC = bwconncomp(PWda);
nspots = CC.NumObjects;
StatsPix = regionprops(PWda,'Centroid');
for i = 1:numel(StatsPix)
    Cen = StatsPix(i).Centroid;
    CK = drawCircle2(sy,sx,Cen,50); % define circles  of 50 pixels radius around spot centers
                                    % radius value depends on magnification
                                    % and image size
    CF = CK & SIW;
    StatsPix(i).Pixbkg = find(CF);  % get local background pixels IDs

end

%% Z-normalize at each frame



progressText(0,'Signal Normalization');
for i = 1:st

    Br = Breg(:,:,i);
    Breg(:,:,i) = (Br - mean2(Br)) ./ std2(Br); % z-normalization of DNA channel

    Rr = Rreg(:,:,i);
    Rreg(:,:,i) = (Rr - mean2(Rr)) ./ std2(Rr); %z-normalization of first channel

    Gr = Greg(:,:,i);
    Greg(:,:,i) = (Gr - mean2(Gr)) ./ std2(Gr); %z-normalization of second channel

    progressText(i/st);
end


%% Compute

% time-series saved as one column per DNA spot, rows are timeframe
SD = zeros(st,nspots); % DNA timeseries
SR = zeros(st,nspots); % 1st channel timeseries
SG = zeros(st,nspots); % 2nd channel timeseries

progressText(0,'Signal Extraction');
for i = 1:st
    Br = Breg(:,:,i); Rr = Rreg(:,:,i); Gr = Greg(:,:,i);
    sd = regionprops(PWda,Breg(:,:,i),'MeanIntensity');
    mbr = cellfun(@(x) mean(Br(x)),{StatsPix.Pixbkg});
    SD(i,:) = [sd.MeanIntensity] - mbr;  %r emove local background
    sr = regionprops(PWda,Rreg(:,:,i),'MeanIntensity');
    mrr = cellfun(@(x) mean(Rr(x)),{StatsPix.Pixbkg});
    SR(i,:) = [sr.MeanIntensity] - mrr;  % remove local background
    sg = regionprops(PWda,Greg(:,:,i),'MeanIntensity');
    mgr = cellfun(@(x) mean(Gr(x)),{StatsPix.Pixbkg});
    SG(i,:) = [sg.MeanIntensity] - mgr;  % remove local background
    progressText(i/st);
end


if any(isnan(SD(:))) % delete traces that contains NaNs
    [~, c] = find(isnan(SD));
    SD(:,c) = [];
    SR(:,c) = [];
    SG(:,c) = [];
    nspots = size(SD,2);
end
% filter  traces with lowpass
SDlp = lowpass(SD,0.01);
SRlp = lowpass(SR,0.01);
SGlp = lowpass(SG,0.01);

if nargin == 4 && ~isempty(varargin{1})

    TR1 = varargin{1};
else
    TR1 = 0.4; % default  threshold for ON/OFF status
end

if nargin == 4 && ~isempty(varargin{2})
    TG1 = varargin{2};
else
    TG1 = 0.4; % default threshold for ON/OFF status ch2
end



SRpulsed = SRlp;
SGpulsed = SGlp;

%% define different levels of ON state -not used for the present analysis- Stochiometric binding?

SRpulsed(SRlp <= TR1 - 0.5 * TR1) = 0;
SRpulsed(SRlp > TR1 - 0.5 * TR1 & SRlp <= (TR1 + 0.5 * TR1)) = 1;
SRpulsed(SRlp > (2 * TR1 - 0.5 * TR1) & SRlp <= (2 * TR1 + 0.5 * TR1)) = 2;
SRpulsed(SRlp > (3 * TR1 - 0.5 * TR1) & SRlp <= (3 * TR1 + 0.5 * TR1)) = 3;
SRpulsed(SRlp > (4 * TR1 - 0.5 * TR1)) = 4;

SGpulsed(SGlp <= TG1 - 0.5 * TG1) = 0;
SGpulsed(SGlp > TG1 - 0.5 * TG1 & SGlp <= (TG1 + 0.5 * TG1)) = 1;
SGpulsed(SGlp > (2 * TG1 - 0.5 * TG1) & SGlp <= (2 * TG1 + 0.5 * TG1)) = 2;
SGpulsed(SGlp > (3 * TG1 - 0.5 * TG1) & SGlp <= (3 * TG1 + 0.5 * TG1)) = 3;
SGpulsed(SGlp > (4 * TG1 - 0.5 * TG1)) = 4; 

% Binarize signal to ON/OFF
SRbin = SRpulsed;
SGbin = SGpulsed;
SRbin(SRbin > 0) = 1;
SGbin(SGbin > 0) = 1;

% fill gaps smaller than 10 frames using imclose and line structural
% element
se = strel('line',10,90);
SRbin = double(imclose(logical(SRbin),se));
SGbin = double(imclose(logical(SGbin),se));


data.SDC.raw = SD;
data.SDC.lowpass = SDlp;

data.SRC.raw = SR;
data.SRC.lowpass = SRlp;
data.SRC.pulsed = SRpulsed;
data.SRC.binary = SRbin;

data.SGC.raw = SG;
data.SGC.lowpass = SGlp;
data.SGC.pulsed = SGpulsed;
data.SGC.binary = SGbin;


%% postanalysis - pulses stats

initR = NaN(nspots,1);
censorR = cell(nspots,1);
dutyR = zeros(nspots,1);
widthR = cell(nspots,1);

initG = NaN(nspots,1);
censorG = cell(nspots,1);
dutyG = zeros(nspots,1);
widthG = cell(nspots,1);

for i = 1:nspots
    SRT = SRbin(:,i);
    SGT = SGbin(:,i);
    [wr,cr] = getPulse(SRT,frameRate);
    [wg,cg] = getPulse(SGT,frameRate);
    [~, ir] = pulsewidth(SRT);
    [~,ig] = pulsewidth(SGT);

    widthR{i}=wr; widthG{i}=wg;
    censorR{i} = logical(cr); censorG{i}=logical(cg);
    if ~isempty(ir)
        initR(i) = ir(1);
    end
    if ~isempty(ig)
        initG(i) = ig(1);
    end
    dutyR(i) = sum(SRT) / numel(SRT);
    dutyG(i) = sum(SGT) / numel(SGT);

end


data.censorR = censorR;
data.WR = widthR;
data.IR = initR * frameRate;
data.dutyR = dutyR;


data.censorG = censorG;
data.WG = widthG;
data.IG = initG * frameRate;
data.dutyG = dutyG;

data.TC1 = TR1;
data.TC2 = TG1;
%% example [plotting]
SK = find(all([sum(SRbin,1); sum(SGbin,1)],1)); % find traces with at least one pulse in each channel

if ~isempty(SK)

    t = randi(numel(SK),1); %choose random trace
    disp(SK(t));

    TRraw = data.SRC.raw(:,SK(t));
    TRlp = data.SRC.lowpass(:,SK(t));
    TRpulsed = data.SRC.pulsed(:,SK(t));
    TRbin = data.SRC.binary(:,SK(t));

else
    t = randi(nspots,1);
    TRraw = data.SRC.raw(:,t);
    TRlp = data.SRC.lowpass(:,t);
    TRpulsed = data.SRC.pulsed(:,t);
    TRbin = data.SRC.binary(:,t);
end



%%% Survival data %%%

RW = vertcat(data.WR{:});
GW = vertcat(data.WG{:});
RC = vertcat(data.censorR{:});
GC = vertcat(data.censorG{:});
survDataR = [RW RC];
survDataG = [GW GC];
survData = [{survDataR} {survDataG}];

%% Plot some data

figure, imshow(BWan,[]); hold on;
for i = 1:length(BB)
    bb = BB{i};
    plot(gca,bb(:,2),bb(:,1),'-r');
end
drawnow;
figure;subplot(1,2,1);
ecdf(RW,'Censoring',RC,'Function','Survivor','Bounds','on');
title('Channel1')
subplot(1,2,2);
ecdf(GW,'Censoring',GC,'Function','Survivor','Bounds','on');
title('Channel2')

xx= (0:st - 1) * frameRate;
figure;
plot(xx,TRraw,'Color',[0.5 0.5 0.5]);hold on;
plot(xx,TRlp,'Linewidth',2,'Color',[0.7176 0.2745 1.0000]);
plot(xx,TRbin,'Linewidth',3,'Color',[0 0.4471 0.7412]);
plot(xx,TRpulsed,'Linewidth',1,'Color',[0.4667 0.6745 0.1882]);
ylim([min(TRraw) max(TRpulsed)+0.5])
legend({'Raw','lowpass','gated','quantum'})
xlabel('Time (s)')
ylabel('z-normalized signal')
drawnow;

end

%%%%%%%%%%%%%%%%% Subfunctions %%%%%%%%%%%%%%%%%%%%%%%%

function thresvalue = minminT(I)

thresvalue = max([min(max(I,[],1)) min(max(I,[],2))])	 ;

end


function CW = drawCircle2(x, y,Centroids,r)
% drawCircle2 creates a binary image of size y-by-x containing full circles
% defined by Centroids and radii r
% INPUT:    -x -y size of MASK image
%           -Centroids numcentroids*2 vector or 2-by-numCentroids matrix
%           containing xy coordinates of circle centroids
%           -r scalar or vector same size of numcentroids defining radius
%           of circles
%
% OUTPUT:   -CW binary image containing circles described by centroids and
%           radii

[X, Y] = meshgrid(1:x,1:y);

BWgrid = false(y,x);
nc = numel(Centroids) / 2;
count = 1;
if numel(r) == 1
    r = repmat(r,nc,1);
elseif numel(r) ~= nc
    error('r must be a scalar or the same size of centroid points.')
end
if any(size(Centroids) == 1)
    for i = 1:nc


        Xc = Centroids(count);
        Yc = Centroids(count + 1);
        radius = r(i);
        bwtemp = sqrt((X-Xc).^2 + (Y-Yc).^2) <= radius;
        BWgrid= BWgrid | bwtemp;
        count = count + 2;
    end

else
    if size(Centroids,1) == 2
        Centroids = Centroids';
    end

    for i=1:nc
        Xc = Centroids(i,1);
        Yc = Centroids(i,2);
        radius = r(i);
        bwtemp = sqrt((X-Xc).^2 + (Y-Yc).^2) <= radius;
        BWgrid= BWgrid | bwtemp;
    end
end

CW = BWgrid;

end

function [pwidth, pcensor] = getPulse(trace,framerate)

% INPUT:    -trace numframe-by-1 vector containing the ON/OFF binarized
%           timeseries -framerate scalar second per frame
%
% OUTPUT:   -pwidth vector containing durations of pulses
%           -pcensor vector (same length as pwidth) describing whether
%           pulse is censored (1) or not (0)

etrace = [0; trace; 0];
dtrace = diff(etrace);
kup = find(dtrace == 1);
kdown = find(dtrace == -1);

pwidth = (kdown - kup) * framerate;
if ~isempty(pwidth)
    pcensor = zeros(size(pwidth));
    pcensor(1) = trace(1); pcensor(end) = trace(end);
else
    pcensor = [];
end

end

